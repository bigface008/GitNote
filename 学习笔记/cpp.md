# C++ 学习笔记

## Features

### 引用

1. 引用必须被初始化。

   > 一般地，在初始化变量时，初始值会被拷贝到新建的对象中。
   >
   > 然而定义引用时，程序把引用和它的初始值绑定（bind）在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另外一个对象，因此引用必须初始化。

2. 引用本身不是一个对象，所以不能定义引用的引用。

3. > 为引用赋值，是把值付给了与引用绑定的对象。获取引用的值，是获取了与引用绑定的对象的值。以引用为初始值，是以与引用绑定的对象作为初始值。

4. 引用初始化时是可以绑定常量的，不过引用本身也必须为常量。

   ```cpp
   int &ref1 = 1;       // X
   const int &ref2 = 1; // V
   ```

### 指针

1. 与引用的不同点。

   - 指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。
   - 指针无需在定义时赋初值。

2. C++11中引入了关键字`nullptr`作为空指针的值。在新的标准下最好用`nullptr`而非`NULL`初始化指针。

3. **指向常量的指针**不能用于改变其所指向的对象的值。要想存放常量对象的地址，只能使用指向常量的指针。

   ```cpp
   const double pi = 3.14;
   double *ptr = &pi;
   const double *cptr = &pi;
   *cptr = 42;
   ```

### `extern`

1. `const`

   关于`const`的坑请详细看**C++ Primer p55**。

   ```cpp
   const in bufSize = 512;
   ```

   P54:

   > 编译器在编译过程中把用到该变量的地方都替换成对应的值。也就是说，编译器会找到代码中所有用到bufSize的地方，然后用512替换。
   > 默认情况下，const对象被设定为仅在文件内有效。
   > 有时候，有的const变量初始值不是一个常量表达，这种变量要在文件间共享的时候，我们通常这么做。

   ```cpp
   /* file1.h头文件中的声明由extern做了限定，其作用是指明bufSize并非本文件独有，它的定义将在别处出现。 */
   extern const int bufSize = fcn(); // file1.cc定义并初始化一个常量，该常量能被其他文件访问。
   extern const int bufSize;         // file1.h头文件，这里面的bufSize和file1.cc中的是同一个。
   ```

## Tips

1. EOF

   EOF这个东西在windows上的输入方法是：Ctrl+Z，然后按Enter。UNIX系统中则是Ctrl+D。

2. `std::endl`的效果是结束当前行，并将与设备关联的buffer中的内容刷到设备中。*buffer刷新的操作可以保证到目前为止程序所产生的所有输出都真正写入输出流中，而不是仅停留在内存中等待写入流*。

3. 函数体内，如果试图初始化一个由`extern`关键字标记的变量，将引发错误。

4. 指定C++标准的版本

   ```shell
   # 貌似Ubuntu 16.04上默认的g++默认不是用C++ 11版本的。
   g++ -std=c++11 -o app main.cpp
   ```
